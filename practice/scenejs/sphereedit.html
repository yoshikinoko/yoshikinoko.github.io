<!DOCTYPE html>
<html lang="en">
<head>
  <title>Edit Sphere Vertex</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
      body {
          background: white;
          margin: 0;
          -moz-user-select: -moz-none;
          -khtml-user-select: none;
          -webkit-user-select: none;
      }
      #info {
          position: absolute;
          top: 0px;
          width: 100%;
          color: #ffffff;
          padding: 5px;
          font-family: Monospace;
          font-size: 18px;
          text-align: left;
          background: black;
          opacity: 0.6;
          z-index: 100000;
      }
  </style>
</head>
<body>
<div id="info">Click on an object to pick it
</div>
<script src="js/jquery-1.11.1.js"></script>
<script src="js/underscore.js"></script>
<script src="scenejs/scenejs.js"></script>
<script>
// Point SceneJS to the bundled plugins
SceneJS.setConfigs({
  pluginPath:"scenejs/plugins"
});

var idname_header = "tid_";
var idname_delimiter = "_";

var id_RootNode = "id_rootNode";
var id_CameraOrbit = "id_camreaOrbit";
var id_SpheresNodeRoot = "id_sphereMaterial";
var id_linesNodeRoot = "id_lineMaterial";
var id_Edgeline = "id_line";

function createIDAndName(latNumber, longNumber){
  var idname = String(idname_header + latNumber + idname_delimiter + longNumber);
  return idname;
}

function createVertexPoint(radius){
  var latitudeBands = 20;
  var longitudeBands = 30;
  var points = [];
  var positions = [];
  var arrayIndexMap = [];
  for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {

    var theta = latNumber * Math.PI / latitudeBands;
    var sinTheta = Math.sin(theta);
    var cosTheta = Math.cos(theta);

    for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
      if(latNumber == 0 && longNumber > 0)
        break;
      if(latNumber == latitudeBands && longNumber > 0)
        break;

      var phi = longNumber * 2 * Math.PI / longitudeBands;
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var x = cosPhi * sinTheta;
      var y = cosTheta;
      var z = sinPhi * sinTheta;
      var xp  = radius * x;
      var yp  = radius * y;
      var zp  = radius * z;
      var idname = createIDAndName(latNumber, longNumber);
      points.push(
        {
          id: idname,
          type:"translate",
          x:xp,
          y:yp,
          z:zp,
          nodes:[{
            type : "name",
            name : idname,
              nodes:[
                {
                    radius:0.1,
                    type:"prims/sphere"
                }]
            }]
        });
      var pi = positions.length;
      var xpi = pi;
      var ypi = pi + 1;
      var zpi = pi + 2;
      var index = {
        id : idname,
        x : xpi,
        y : ypi,
        z : zpi,
      };
      arrayIndexMap.push(index);
      positions.push(xp);
      positions.push(yp);
      positions.push(zp);
     

    }
  }

  var indices = [];

  for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
      for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
        var first = (latNumber  - 1 ) * longitudeBands + longNumber + 1;
        var second = first + longitudeBands ;
        var next = first + 1;
        if(longNumber ==  (longitudeBands -1))
          next -= longitudeBands ;

        if(latNumber == 0 ){
          //For the top
          first = 0;
          second = longNumber +1;
          next = second + 1;
          if(longNumber ==  (longitudeBands -1))
            next -= longitudeBands;
          indices.push(first);
          indices.push(second);
          indices.push(first);
          indices.push(next);
        }else if(latNumber == (latitudeBands -1 )){
          //For the bottom
          second = 1 + longitudeBands * (latitudeBands - 1 );
          indices.push(first);
          indices.push(second);
          indices.push(first);
          indices.push(next);
        }else{
          indices.push(first);
          indices.push(second);
          indices.push(first);
          indices.push(next);
          indices.push(second);
          indices.push(next);
        }
      }
  }
  var lines = {
    id : id_Edgeline,
    type:"geometry",
    primitive:"lines",
    positions:positions,
    indices:indices
  }
  var result = {};
  result.points = points;
  result.indicies = lines;
  result.positions = positions;
  result.pointsIndexies = arrayIndexMap;
  return result;
}

var nodeRoot ={
  id: id_RootNode,
  nodes:[]
};

var nodeCamera ={
  id : id_CameraOrbit,
  type:"cameras/orbit2",
  yaw:0,
  pitch:0,
  zoom:50,
  zoomSensitivity:0.1,
  nodes:[]
}

//spheres in the vertex
var nodeMaterial = {
  id:id_SpheresNodeRoot,
  type:"material",
  color:{ r:0.6, g:0.6, b:0.9 },
  nodes:[]
}
//lines
var nodeMaterialIndices = {
  id : id_linesNodeRoot,
  type:"material",
  //Color mycolor = new Color(0.07,0.32,0.64,1);
  color:{ r:0.07 , g:0.32, b:0.64 },
  nodes:[]
}

var sphere = createVertexPoint(10);

for(var i = 0 ; i < sphere.points.length; i++){
  nodeMaterial.nodes.push(sphere.points[i]);
}
nodeMaterialIndices.nodes.push(sphere.indicies);
nodeCamera.nodes.push(nodeMaterial);
nodeCamera.nodes.push(nodeMaterialIndices);
nodeRoot.nodes.push(nodeCamera);

var myScene = SceneJS.createScene(nodeRoot);
var canvas = myScene.getCanvas();

var ObjID;
var ClickPos;
var ObjOriginalPos;
var moving;

function OrbitCameraMatrix(MouseX, MouseY){
  myScene.getNode(id_CameraOrbit,function (cameraOrbit) {
    myScene.getNode(ObjID, function (movingObject) {
      myScene.getNode(id_Edgeline, function (edgeLineObject) {
        if(cameraOrbit){
          var cameraMatrix;
          var eye;
          var look;
          cameraMatrix = cameraOrbit.nodes[0].getMatrix();
          eye = cameraOrbit.nodes[0].getEye();
          look = cameraOrbit.nodes[0].getLook();
          if(movingObject){
            if(!ObjOriginalPos){
              ObjOriginalPos = movingObject.getXYZ();
            }

            //X Vector of World Matrix
            VecRight = {
              x : cameraMatrix[0],
              y : cameraMatrix[4],
              z : cameraMatrix[8],
            };

            //Y Vector of World Matrix
            VecUp = {
              x : cameraMatrix[1],
              y : cameraMatrix[5],
              z : cameraMatrix[9],
            };

            //Z Vector of World Matrix
            VecZ = {
              x : cameraMatrix[2],
              y : cameraMatrix[6],
              z : cameraMatrix[10],
            };

            //Vector from eye to selected Object
            VecTgtFmEye = {
              x : ObjOriginalPos.x - eye.x,
              y : ObjOriginalPos.y - eye.y,
              z : ObjOriginalPos.z - eye.z,
            }

            //Cross product of VecZ and Vector from eye to target
            var distance = VecTgtFmEye.x * VecZ.x + VecTgtFmEye.y * VecZ.y + VecTgtFmEye.z * VecZ.z;

            var MouseDiff = {
              x : ClickPos.x - MouseX,
              y : (ClickPos.y - MouseY) * -1
            }

            var PosDiff = {
              x : VecRight.x * MouseDiff.x + VecUp.x * MouseDiff.y,
              y : VecRight.y * MouseDiff.x + VecUp.y * MouseDiff.y,
              z : VecRight.z * MouseDiff.x + VecUp.z * MouseDiff.y
            }

            PosDiff.x *= distance;
            PosDiff.y *= distance;
            PosDiff.z *= distance;

            var newPosition = {
            x : ObjOriginalPos.x + PosDiff.x , 
            y : ObjOriginalPos.y + PosDiff.y , 
            z : ObjOriginalPos.z + PosDiff.z ,
            };


            movingObject.setXYZ(newPosition);

            var msgP = {
              x: newPosition.x.toFixed(2),
              y: newPosition.y.toFixed(2),
              z: newPosition.z.toFixed(2)
            };


            var edgeList =  _.filter(sphere.pointsIndexies, function(v){
                return v.id == ObjID;
            });

            sphere.positions[edgeList[0].x] = newPosition.x;
            sphere.positions[edgeList[0].y] = newPosition.y;
            sphere.positions[edgeList[0].z] = newPosition.z;

            console.log("edges");
            console.log(edgeList);
            var labelMessage = "Moving : " + ObjID + " x:"  +msgP.x + " y:" + msgP.y + " z:" + msgP.z;
            edgeLineObject.setPositions({positions:sphere.positions});

            UpdateLabelMessage(labelMessage);
          }
        }
      })
    })
  })
}

function OrbitCameraDisable(){
  myScene.getNode(id_CameraOrbit,function (cameraOrbit) {
    if(cameraOrbit){
      cameraOrbit.OrbitCameraDisable();
    }
  });
}

function OrbitCameraEnable(){
  myScene.getNode(id_CameraOrbit,function (cameraOrbit) {
    if(cameraOrbit){
      cameraOrbit.OrbitCameraEnable();
    }
  });
}


function GetObjectPosition(object_id){
  myScene.getNode(object_id,function (obj) {
    if(obj){
      ObjOriginalPos ={
        x: obj.x,
        y: obj.y,
        z: obj.z
      };
    }
  });
}


function UpdateLabelMessage(message){
  info.innerHTML = message;
}

myScene.on("pick",function (hit) {

  if(!moving){
    info.innerHTML = "Pick hit: " + JSON.stringify(hit);
    ObjID = hit.name;
    //disable motion of orbit camera
    OrbitCameraDisable();
    //Set the original click point
    ClickPos = {
      x: (hit.canvasPos[0] - canvas.width /2.0) / (canvas.width ), 
      y: (hit.canvasPos[1] - canvas.height/2.0) / (canvas.height)
    };
    GetObjectPosition(ObjID);
    ObjOriginalPos = null;
    moving = true;
  }
});

// Called when nothing picked
myScene.on("nopick",function (hit) {
  UpdateLabelMessage("Nothing picked.");
});

canvas.addEventListener('mousedown',function (event) {
  myScene.pick(event.clientX, event.clientY);
}, true);

canvas.addEventListener('mouseup',function (event) {
  if(moving){
    OrbitCameraEnable();
  }
  moving = false;
}, true);


canvas.addEventListener('mousemove',function (event) {
  if(moving){
    var mouseX =  (event.clientX - canvas.width/2.0) / (canvas.width);
    var mouseY =  (event.clientY  - canvas.height/2.0)/ (canvas.height);
    OrbitCameraMatrix(mouseX, mouseY);
  }
}, true);

canvas.addEventListener('touchstart',function touchStart(event) {
  lastX = event.targetTouches[0].clientX;
  lastY = event.targetTouches[0].clientY;
}, true);

canvas.addEventListener('touchend',function touchEnd(event) {
  if (dragging && event.targetTouches[0].clientX == lastX && event.targetTouches[0].clientY == lastY) {
      // Do pick
      myScene.pick(event.targetTouches[0].clientX, event.targetTouches[0].clientY);
  }
  console.log("touched");
}, true);

</script>
</body>
</html>
